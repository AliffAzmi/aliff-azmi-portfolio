function noop() { }
function run(fn) {
    return fn();
}
function blank_object() {
    return Object.create(null);
}
function run_all(fns) {
    fns.forEach(run);
}
function is_function(thing) {
    return typeof thing === 'function';
}
function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
}
function is_empty(obj) {
    return Object.keys(obj).length === 0;
}

// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM
// at the end of hydration without touching the remaining nodes.
let is_hydrating = false;
function start_hydrating() {
    is_hydrating = true;
}
function end_hydrating() {
    is_hydrating = false;
}
function upper_bound(low, high, key, value) {
    // Return first index of value larger than input value in the range [low, high)
    while (low < high) {
        const mid = low + ((high - low) >> 1);
        if (key(mid) <= value) {
            low = mid + 1;
        }
        else {
            high = mid;
        }
    }
    return low;
}
function init_hydrate(target) {
    if (target.hydrate_init)
        return;
    target.hydrate_init = true;
    // We know that all children have claim_order values since the unclaimed have been detached
    const children = target.childNodes;
    /*
    * Reorder claimed children optimally.
    * We can reorder claimed children optimally by finding the longest subsequence of
    * nodes that are already claimed in order and only moving the rest. The longest
    * subsequence subsequence of nodes that are claimed in order can be found by
    * computing the longest increasing subsequence of .claim_order values.
    *
    * This algorithm is optimal in generating the least amount of reorder operations
    * possible.
    *
    * Proof:
    * We know that, given a set of reordering operations, the nodes that do not move
    * always form an increasing subsequence, since they do not move among each other
    * meaning that they must be already ordered among each other. Thus, the maximal
    * set of nodes that do not move form a longest increasing subsequence.
    */
    // Compute longest increasing subsequence
    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j
    const m = new Int32Array(children.length + 1);
    // Predecessor indices + 1
    const p = new Int32Array(children.length);
    m[0] = -1;
    let longest = 0;
    for (let i = 0; i < children.length; i++) {
        const current = children[i].claim_order;
        // Find the largest subsequence length such that it ends in a value less than our current value
        // upper_bound returns first greater value, so we subtract one
        const seqLen = upper_bound(1, longest + 1, idx => children[m[idx]].claim_order, current) - 1;
        p[i] = m[seqLen] + 1;
        const newLen = seqLen + 1;
        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.
        m[newLen] = i;
        longest = Math.max(newLen, longest);
    }
    // The longest increasing subsequence of nodes (initially reversed)
    const lis = [];
    // The rest of the nodes, nodes that will be moved
    const toMove = [];
    let last = children.length - 1;
    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {
        lis.push(children[cur - 1]);
        for (; last >= cur; last--) {
            toMove.push(children[last]);
        }
        last--;
    }
    for (; last >= 0; last--) {
        toMove.push(children[last]);
    }
    lis.reverse();
    // We sort the nodes being moved to guarantee that their insertion order matches the claim order
    toMove.sort((a, b) => a.claim_order - b.claim_order);
    // Finally, we move the nodes
    for (let i = 0, j = 0; i < toMove.length; i++) {
        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {
            j++;
        }
        const anchor = j < lis.length ? lis[j] : null;
        target.insertBefore(toMove[i], anchor);
    }
}
function append(target, node) {
    if (is_hydrating) {
        init_hydrate(target);
        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {
            target.actual_end_child = target.firstChild;
        }
        if (node !== target.actual_end_child) {
            target.insertBefore(node, target.actual_end_child);
        }
        else {
            target.actual_end_child = node.nextSibling;
        }
    }
    else if (node.parentNode !== target) {
        target.appendChild(node);
    }
}
function insert(target, node, anchor) {
    if (is_hydrating && !anchor) {
        append(target, node);
    }
    else if (node.parentNode !== target || (anchor && node.nextSibling !== anchor)) {
        target.insertBefore(node, anchor || null);
    }
}
function detach(node) {
    node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
    for (let i = 0; i < iterations.length; i += 1) {
        if (iterations[i])
            iterations[i].d(detaching);
    }
}
function element(name) {
    return document.createElement(name);
}
function text(data) {
    return document.createTextNode(data);
}
function space() {
    return text(' ');
}
function attr(node, attribute, value) {
    if (value == null)
        node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
        node.setAttribute(attribute, value);
}
function children(element) {
    return Array.from(element.childNodes);
}
function set_style(node, key, value, important) {
    node.style.setProperty(key, value, important ? 'important' : '');
}

let current_component;
function set_current_component(component) {
    current_component = component;
}

const dirty_components = [];
const binding_callbacks = [];
const render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = Promise.resolve();
let update_scheduled = false;
function schedule_update() {
    if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
    }
}
function add_render_callback(fn) {
    render_callbacks.push(fn);
}
let flushing = false;
const seen_callbacks = new Set();
function flush() {
    if (flushing)
        return;
    flushing = true;
    do {
        // first, call beforeUpdate functions
        // and update components
        for (let i = 0; i < dirty_components.length; i += 1) {
            const component = dirty_components[i];
            set_current_component(component);
            update(component.$$);
        }
        set_current_component(null);
        dirty_components.length = 0;
        while (binding_callbacks.length)
            binding_callbacks.pop()();
        // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...
        for (let i = 0; i < render_callbacks.length; i += 1) {
            const callback = render_callbacks[i];
            if (!seen_callbacks.has(callback)) {
                // ...so guard against infinite loops
                seen_callbacks.add(callback);
                callback();
            }
        }
        render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
        flush_callbacks.pop()();
    }
    update_scheduled = false;
    flushing = false;
    seen_callbacks.clear();
}
function update($$) {
    if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
    }
}
const outroing = new Set();
function transition_in(block, local) {
    if (block && block.i) {
        outroing.delete(block);
        block.i(local);
    }
}
function mount_component(component, target, anchor, customElement) {
    const { fragment, on_mount, on_destroy, after_update } = component.$$;
    fragment && fragment.m(target, anchor);
    if (!customElement) {
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
    }
    after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
    }
}
function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
    }
    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
}
function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const $$ = component.$$ = {
        fragment: null,
        ctx: null,
        // state
        props,
        update: noop,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        on_disconnect: [],
        before_update: [],
        after_update: [],
        context: new Map(parent_component ? parent_component.$$.context : options.context || []),
        // everything else
        callbacks: blank_object(),
        dirty,
        skip_bound: false
    };
    let ready = false;
    $$.ctx = instance
        ? instance(component, options.props || {}, (i, ret, ...rest) => {
            const value = rest.length ? rest[0] : ret;
            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                if (!$$.skip_bound && $$.bound[i])
                    $$.bound[i](value);
                if (ready)
                    make_dirty(component, i);
            }
            return ret;
        })
        : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    // `false` as a special case of no DOM component
    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
    if (options.target) {
        if (options.hydrate) {
            start_hydrating();
            const nodes = children(options.target);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.l(nodes);
            nodes.forEach(detach);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.c();
        }
        if (options.intro)
            transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor, options.customElement);
        end_hydrating();
        flush();
    }
    set_current_component(parent_component);
}
/**
 * Base class for Svelte components. Used when dev=false.
 */
class SvelteComponent {
    $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
    }
    $on(type, callback) {
        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
        callbacks.push(callback);
        return () => {
            const index = callbacks.indexOf(callback);
            if (index !== -1)
                callbacks.splice(index, 1);
        };
    }
    $set($$props) {
        if (this.$$set && !is_empty($$props)) {
            this.$$.skip_bound = true;
            this.$$set($$props);
            this.$$.skip_bound = false;
        }
    }
}

/* src\Circle.svelte generated by Svelte v3.38.3 */

function add_css$n() {
	var style = element("style");
	style.id = "svelte-14upwad-style";
	style.textContent = ".circle.svelte-14upwad{height:var(--size);width:var(--size);border-color:var(--color) transparent var(--color) var(--color);border-width:calc(var(--size) / 15);border-style:solid;border-image:initial;border-radius:50%;animation:var(--duration) linear 0s infinite normal none running svelte-14upwad-rotate}@keyframes svelte-14upwad-rotate{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}";
	append(document.head, style);
}

function create_fragment$n(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			attr(div, "class", "circle svelte-14upwad");
			set_style(div, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			set_style(div, "--color", /*color*/ ctx[0]);
			set_style(div, "--duration", /*duration*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size, unit*/ 10) {
				set_style(div, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			}

			if (dirty & /*color*/ 1) {
				set_style(div, "--color", /*color*/ ctx[0]);
			}

			if (dirty & /*duration*/ 4) {
				set_style(div, "--duration", /*duration*/ ctx[2]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function instance$n($$self, $$props, $$invalidate) {
	
	let { color = "#FF3E00" } = $$props;
	let { unit = "px" } = $$props;
	let { duration = "0.75s" } = $$props;
	let { size = "60" } = $$props;

	$$self.$$set = $$props => {
		if ("color" in $$props) $$invalidate(0, color = $$props.color);
		if ("unit" in $$props) $$invalidate(1, unit = $$props.unit);
		if ("duration" in $$props) $$invalidate(2, duration = $$props.duration);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
	};

	return [color, unit, duration, size];
}

class Circle extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-14upwad-style")) add_css$n();
		init(this, options, instance$n, create_fragment$n, safe_not_equal, { color: 0, unit: 1, duration: 2, size: 3 });
	}
}

/* src\Circle2.svelte generated by Svelte v3.38.3 */

function add_css$m() {
	var style = element("style");
	style.id = "svelte-1vclic6-style";
	style.textContent = ".circle.svelte-1vclic6{width:var(--size);height:var(--size);box-sizing:border-box;position:relative;border:3px solid transparent;border-top-color:var(--colorOuter);border-radius:50%;animation:svelte-1vclic6-circleSpin var(--durationOuter) linear infinite}.circle.svelte-1vclic6:before,.circle.svelte-1vclic6:after{content:\"\";box-sizing:border-box;position:absolute;border:3px solid transparent;border-radius:50%}.circle.svelte-1vclic6:after{border-top-color:var(--colorInner);top:9px;left:9px;right:9px;bottom:9px;animation:svelte-1vclic6-circleSpin var(--durationInner) linear infinite}.circle.svelte-1vclic6:before{border-top-color:var(--colorCenter);top:3px;left:3px;right:3px;bottom:3px;animation:svelte-1vclic6-circleSpin var(--durationCenter) linear infinite}@keyframes svelte-1vclic6-circleSpin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}";
	append(document.head, style);
}

function create_fragment$m(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			attr(div, "class", "circle svelte-1vclic6");
			set_style(div, "--size", /*size*/ ctx[0] + /*unit*/ ctx[1]);
			set_style(div, "--colorInner", /*colorInner*/ ctx[4]);
			set_style(div, "--colorCenter", /*colorCenter*/ ctx[3]);
			set_style(div, "--colorOuter", /*colorOuter*/ ctx[2]);
			set_style(div, "--durationInner", /*durationInner*/ ctx[6]);
			set_style(div, "--durationCenter", /*durationCenter*/ ctx[7]);
			set_style(div, "--durationOuter", /*durationOuter*/ ctx[5]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size, unit*/ 3) {
				set_style(div, "--size", /*size*/ ctx[0] + /*unit*/ ctx[1]);
			}

			if (dirty & /*colorInner*/ 16) {
				set_style(div, "--colorInner", /*colorInner*/ ctx[4]);
			}

			if (dirty & /*colorCenter*/ 8) {
				set_style(div, "--colorCenter", /*colorCenter*/ ctx[3]);
			}

			if (dirty & /*colorOuter*/ 4) {
				set_style(div, "--colorOuter", /*colorOuter*/ ctx[2]);
			}

			if (dirty & /*durationInner*/ 64) {
				set_style(div, "--durationInner", /*durationInner*/ ctx[6]);
			}

			if (dirty & /*durationCenter*/ 128) {
				set_style(div, "--durationCenter", /*durationCenter*/ ctx[7]);
			}

			if (dirty & /*durationOuter*/ 32) {
				set_style(div, "--durationOuter", /*durationOuter*/ ctx[5]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function instance$m($$self, $$props, $$invalidate) {
	let { size = "60" } = $$props;
	let { unit = "px" } = $$props;
	let { colorOuter = "#FF3E00" } = $$props;
	let { colorCenter = "#40B3FF" } = $$props;
	let { colorInner = "#676778" } = $$props;
	let { durationMultiplier = 1 } = $$props;
	let { durationOuter = `${durationMultiplier * 2}s` } = $$props;
	let { durationInner = `${durationMultiplier * 1.5}s` } = $$props;
	let { durationCenter = `${durationMultiplier * 3}s` } = $$props;

	$$self.$$set = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("unit" in $$props) $$invalidate(1, unit = $$props.unit);
		if ("colorOuter" in $$props) $$invalidate(2, colorOuter = $$props.colorOuter);
		if ("colorCenter" in $$props) $$invalidate(3, colorCenter = $$props.colorCenter);
		if ("colorInner" in $$props) $$invalidate(4, colorInner = $$props.colorInner);
		if ("durationMultiplier" in $$props) $$invalidate(8, durationMultiplier = $$props.durationMultiplier);
		if ("durationOuter" in $$props) $$invalidate(5, durationOuter = $$props.durationOuter);
		if ("durationInner" in $$props) $$invalidate(6, durationInner = $$props.durationInner);
		if ("durationCenter" in $$props) $$invalidate(7, durationCenter = $$props.durationCenter);
	};

	return [
		size,
		unit,
		colorOuter,
		colorCenter,
		colorInner,
		durationOuter,
		durationInner,
		durationCenter,
		durationMultiplier
	];
}

class Circle2 extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1vclic6-style")) add_css$m();

		init(this, options, instance$m, create_fragment$m, safe_not_equal, {
			size: 0,
			unit: 1,
			colorOuter: 2,
			colorCenter: 3,
			colorInner: 4,
			durationMultiplier: 8,
			durationOuter: 5,
			durationInner: 6,
			durationCenter: 7
		});
	}
}

/* src\Circle3.svelte generated by Svelte v3.38.3 */

function add_css$l() {
	var style = element("style");
	style.id = "svelte-1vf8im1-style";
	style.textContent = ".wrapper.svelte-1vf8im1{width:var(--size);height:var(--size);display:flex;justify-content:center;align-items:center;line-height:0;box-sizing:border-box}.inner.svelte-1vf8im1{transform:scale(calc(var(--floatSize) / 52))}.ball-container.svelte-1vf8im1{animation:svelte-1vf8im1-ballTwo var(--duration) infinite;width:44px;height:44px;flex-shrink:0;position:relative}.single-ball.svelte-1vf8im1{width:44px;height:44px;position:absolute}.ball.svelte-1vf8im1{width:20px;height:20px;border-radius:50%;position:absolute;animation:svelte-1vf8im1-ballOne var(--duration) infinite ease}.ball-top-left.svelte-1vf8im1{background-color:var(--ballTopLeftColor);top:0;left:0}.ball-top-right.svelte-1vf8im1{background-color:var(--ballTopRightColor);top:0;left:24px}.ball-bottom-left.svelte-1vf8im1{background-color:var(--ballBottomLeftColor);top:24px;left:0}.ball-bottom-right.svelte-1vf8im1{background-color:var(--ballBottomRightColor);top:24px;left:24px}@keyframes svelte-1vf8im1-ballOne{0%{position:absolute}50%{top:12px;left:12px;position:absolute;opacity:0.5}100%{position:absolute}}@keyframes svelte-1vf8im1-ballTwo{0%{transform:rotate(0deg) scale(1)}50%{transform:rotate(360deg) scale(1.3)}100%{transform:rotate(720deg) scale(1)}}";
	append(document.head, style);
}

function create_fragment$l(ctx) {
	let div10;
	let div9;

	return {
		c() {
			div10 = element("div");
			div9 = element("div");

			div9.innerHTML = `<div class="ball-container svelte-1vf8im1"><div class="single-ball svelte-1vf8im1"><div class="ball ball-top-left svelte-1vf8im1"> </div></div> 
      <div class="contener_mixte"><div class="ball ball-top-right svelte-1vf8im1"> </div></div> 
      <div class="contener_mixte"><div class="ball ball-bottom-left svelte-1vf8im1"> </div></div> 
      <div class="contener_mixte"><div class="ball ball-bottom-right svelte-1vf8im1"> </div></div></div>`;

			attr(div9, "class", "inner svelte-1vf8im1");
			attr(div10, "class", "wrapper svelte-1vf8im1");
			set_style(div10, "--size", /*size*/ ctx[0] + /*unit*/ ctx[1]);
			set_style(div10, "--floatSize", /*size*/ ctx[0]);
			set_style(div10, "--ballTopLeftColor", /*ballTopLeft*/ ctx[2]);
			set_style(div10, "--ballTopRightColor", /*ballTopRight*/ ctx[3]);
			set_style(div10, "--ballBottomLeftColor", /*ballBottomLeft*/ ctx[4]);
			set_style(div10, "--ballBottomRightColor", /*ballBottomRight*/ ctx[5]);
			set_style(div10, "--duration", /*duration*/ ctx[6]);
		},
		m(target, anchor) {
			insert(target, div10, anchor);
			append(div10, div9);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size, unit*/ 3) {
				set_style(div10, "--size", /*size*/ ctx[0] + /*unit*/ ctx[1]);
			}

			if (dirty & /*size*/ 1) {
				set_style(div10, "--floatSize", /*size*/ ctx[0]);
			}

			if (dirty & /*ballTopLeft*/ 4) {
				set_style(div10, "--ballTopLeftColor", /*ballTopLeft*/ ctx[2]);
			}

			if (dirty & /*ballTopRight*/ 8) {
				set_style(div10, "--ballTopRightColor", /*ballTopRight*/ ctx[3]);
			}

			if (dirty & /*ballBottomLeft*/ 16) {
				set_style(div10, "--ballBottomLeftColor", /*ballBottomLeft*/ ctx[4]);
			}

			if (dirty & /*ballBottomRight*/ 32) {
				set_style(div10, "--ballBottomRightColor", /*ballBottomRight*/ ctx[5]);
			}

			if (dirty & /*duration*/ 64) {
				set_style(div10, "--duration", /*duration*/ ctx[6]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div10);
		}
	};
}

function instance$l($$self, $$props, $$invalidate) {
	let { size = "60" } = $$props;
	let { unit = "px" } = $$props;
	let { ballTopLeft = "#FF3E00" } = $$props;
	let { ballTopRight = "#F8B334" } = $$props;
	let { ballBottomLeft = "#40B3FF" } = $$props;
	let { ballBottomRight = "#676778" } = $$props;
	let { duration = "1.5s" } = $$props;

	$$self.$$set = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("unit" in $$props) $$invalidate(1, unit = $$props.unit);
		if ("ballTopLeft" in $$props) $$invalidate(2, ballTopLeft = $$props.ballTopLeft);
		if ("ballTopRight" in $$props) $$invalidate(3, ballTopRight = $$props.ballTopRight);
		if ("ballBottomLeft" in $$props) $$invalidate(4, ballBottomLeft = $$props.ballBottomLeft);
		if ("ballBottomRight" in $$props) $$invalidate(5, ballBottomRight = $$props.ballBottomRight);
		if ("duration" in $$props) $$invalidate(6, duration = $$props.duration);
	};

	return [
		size,
		unit,
		ballTopLeft,
		ballTopRight,
		ballBottomLeft,
		ballBottomRight,
		duration
	];
}

class Circle3 extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1vf8im1-style")) add_css$l();

		init(this, options, instance$l, create_fragment$l, safe_not_equal, {
			size: 0,
			unit: 1,
			ballTopLeft: 2,
			ballTopRight: 3,
			ballBottomLeft: 4,
			ballBottomRight: 5,
			duration: 6
		});
	}
}

const durationUnitRegex = /[a-zA-Z]/;
const calculateRgba = (color, opacity) => {
    if (color[0] === "#") {
        color = color.slice(1);
    }
    if (color.length === 3) {
        let res = "";
        color.split("").forEach((c) => {
            res += c;
            res += c;
        });
        color = res;
    }
    const rgbValues = (color.match(/.{2}/g) || [])
        .map((hex) => parseInt(hex, 16))
        .join(", ");
    return `rgba(${rgbValues}, ${opacity})`;
};
const range = (size, startAt = 0) => [...Array(size).keys()].map(i => i + startAt);
// export const characterRange = (startChar, endChar) =>
//   String.fromCharCode(
//     ...range(
//       endChar.charCodeAt(0) - startChar.charCodeAt(0),
//       startChar.charCodeAt(0)
//     )
//   );
// export const zip = (arr, ...arrs) =>
//   arr.map((val, i) => arrs.reduce((list, curr) => [...list, curr[i]], [val]));

/* src\DoubleBounce.svelte generated by Svelte v3.38.3 */

function add_css$k() {
	var style = element("style");
	style.id = "svelte-h1a2xs-style";
	style.textContent = ".wrapper.svelte-h1a2xs{position:relative;width:var(--size);height:var(--size)}.circle.svelte-h1a2xs{position:absolute;width:var(--size);height:var(--size);background-color:var(--color);border-radius:100%;opacity:0.6;top:0;left:0;animation-fill-mode:both;animation-name:svelte-h1a2xs-bounce !important}@keyframes svelte-h1a2xs-bounce{0%,100%{transform:scale(0)}50%{transform:scale(1)}}";
	append(document.head, style);
}

function get_each_context$9(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[6] = list[i];
	return child_ctx;
}

// (41:2) {#each range(2, 1) as version}
function create_each_block$9(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			attr(div, "class", "circle svelte-h1a2xs");

			set_style(div, "animation", /*duration*/ ctx[2] + " " + (/*version*/ ctx[6] === 1
			? `${(/*durationNum*/ ctx[5] - 0.1) / 2}${/*durationUnit*/ ctx[4]}`
			: `0s`) + " infinite ease-in-out");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*duration*/ 4) {
				set_style(div, "animation", /*duration*/ ctx[2] + " " + (/*version*/ ctx[6] === 1
				? `${(/*durationNum*/ ctx[5] - 0.1) / 2}${/*durationUnit*/ ctx[4]}`
				: `0s`) + " infinite ease-in-out");
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment$k(ctx) {
	let div;
	let each_value = range(2, 1);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div, "class", "wrapper svelte-h1a2xs");
			set_style(div, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			set_style(div, "--color", /*color*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*duration, range, durationNum, durationUnit*/ 52) {
				each_value = range(2, 1);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$9(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$9(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*size, unit*/ 10) {
				set_style(div, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			}

			if (dirty & /*color*/ 1) {
				set_style(div, "--color", /*color*/ ctx[0]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

function instance$k($$self, $$props, $$invalidate) {
	
	let { color = "#FF3E00" } = $$props;
	let { unit = "px" } = $$props;
	let { duration = "2.1s" } = $$props;
	let { size = "60" } = $$props;
	let durationUnit = duration.match(durationUnitRegex)[0];
	let durationNum = duration.replace(durationUnitRegex, "");

	$$self.$$set = $$props => {
		if ("color" in $$props) $$invalidate(0, color = $$props.color);
		if ("unit" in $$props) $$invalidate(1, unit = $$props.unit);
		if ("duration" in $$props) $$invalidate(2, duration = $$props.duration);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
	};

	return [color, unit, duration, size, durationUnit, durationNum];
}

class DoubleBounce extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-h1a2xs-style")) add_css$k();
		init(this, options, instance$k, create_fragment$k, safe_not_equal, { color: 0, unit: 1, duration: 2, size: 3 });
	}
}

/* src\GoogleSpin.svelte generated by Svelte v3.38.3 */

function add_css$j() {
	var style = element("style");
	style.id = "svelte-1exboqr-style";
	style.textContent = ".svelte-1exboqr{overflow:hidden;position:relative;text-indent:-9999px;display:inline-block;background:#f86;border-radius:50%;transform:rotateZ(90deg);transform-origin:50% 50%;animation:svelte-1exboqr-plus-loader-background var(--duration) infinite ease-in-out}.svelte-1exboqr:after{background:#f86;border-radius:50% 0 0 50%;content:\"\";position:absolute;right:50%;top:0;width:50%;height:100%;transform-origin:100% 50%;animation:svelte-1exboqr-plus-loader-top var(--duration) infinite linear}.svelte-1exboqr:before{background:#fc6;border-radius:50% 0 0 50%;content:\"\";position:absolute;right:50%;top:0;width:50%;height:100%;transform-origin:100% 50%;animation:svelte-1exboqr-plus-loader-bottom var(--duration) infinite linear}@keyframes svelte-1exboqr-plus-loader-top{2.5%{background:#f86;transform:rotateY(0deg);animation-timing-function:ease-in}13.75%{background:#ff430d;transform:rotateY(90deg);animation-timing-function:step-start}13.76%{background:#ffae0d;transform:rotateY(90deg);animation-timing-function:ease-out}25%{background:#fc6;transform:rotateY(180deg)}27.5%{background:#fc6;transform:rotateY(180deg);animation-timing-function:ease-in}41.25%{background:#ffae0d;transform:rotateY(90deg);animation-timing-function:step-start}41.26%{background:#2cc642;transform:rotateY(90deg);animation-timing-function:ease-out}50%{background:#6d7;transform:rotateY(0deg)}52.5%{background:#6d7;transform:rotateY(0deg);animation-timing-function:ease-in}63.75%{background:#2cc642;transform:rotateY(90deg);animation-timing-function:step-start}63.76%{background:#1386d2;transform:rotateY(90deg);animation-timing-function:ease-out}75%{background:#4ae;transform:rotateY(180deg)}77.5%{background:#4ae;transform:rotateY(180deg);animation-timing-function:ease-in}91.25%{background:#1386d2;transform:rotateY(90deg);animation-timing-function:step-start}91.26%{background:#ff430d;transform:rotateY(90deg);animation-timing-function:ease-in}100%{background:#f86;transform:rotateY(0deg);animation-timing-function:step-start}}@keyframes svelte-1exboqr-plus-loader-bottom{0%{background:#fc6;animation-timing-function:step-start}50%{background:#fc6;animation-timing-function:step-start}75%{background:#4ae;animation-timing-function:step-start}100%{background:#4ae;animation-timing-function:step-start}}@keyframes svelte-1exboqr-plus-loader-background{0%{background:#f86;transform:rotateZ(180deg)}25%{background:#f86;transform:rotateZ(180deg);animation-timing-function:step-start}27.5%{background:#6d7;transform:rotateZ(90deg)}50%{background:#6d7;transform:rotateZ(90deg);animation-timing-function:step-start}52.5%{background:#6d7;transform:rotateZ(0deg)}75%{background:#6d7;transform:rotateZ(0deg);animation-timing-function:step-start}77.5%{background:#f86;transform:rotateZ(270deg)}100%{background:#f86;transform:rotateZ(270deg);animation-timing-function:step-start}}";
	append(document.head, style);
}

function create_fragment$j(ctx) {
	let div;
	let div_style_value;

	return {
		c() {
			div = element("div");
			attr(div, "class", "spinner spinner--google svelte-1exboqr");
			attr(div, "style", div_style_value = "--duration: " + /*duration*/ ctx[0] + "; " + /*styles*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p(ctx, [dirty]) {
			if (dirty & /*duration, styles*/ 3 && div_style_value !== (div_style_value = "--duration: " + /*duration*/ ctx[0] + "; " + /*styles*/ ctx[1])) {
				attr(div, "style", div_style_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function instance$j($$self, $$props, $$invalidate) {
	let styles;
	let { size = "40px" } = $$props;
	let { duration = "3s" } = $$props;

	$$self.$$set = $$props => {
		if ("size" in $$props) $$invalidate(2, size = $$props.size);
		if ("duration" in $$props) $$invalidate(0, duration = $$props.duration);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 4) {
			$$invalidate(1, styles = [`width: ${size}`, `height: ${size}`].join(";"));
		}
	};

	return [duration, styles, size];
}

class GoogleSpin extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1exboqr-style")) add_css$j();
		init(this, options, instance$j, create_fragment$j, safe_not_equal, { size: 2, duration: 0 });
	}
}

/* src\ScaleOut.svelte generated by Svelte v3.38.3 */

function add_css$i() {
	var style = element("style");
	style.id = "svelte-9juun5-style";
	style.textContent = ".wrapper.svelte-9juun5{width:var(--size);height:var(--size)}.circle.svelte-9juun5{width:var(--size);height:var(--size);background-color:var(--color);animation-duration:var(--duration);border-radius:100%;display:inline-block;animation:svelte-9juun5-scaleOut var(--duration) ease-in-out infinite}@keyframes svelte-9juun5-scaleOut{0%{transform:scale(0)}100%{transform:scale(1);opacity:0}}";
	append(document.head, style);
}

function create_fragment$i(ctx) {
	let div1;
	let div0;

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			attr(div0, "class", "circle svelte-9juun5");
			attr(div1, "class", "wrapper svelte-9juun5");
			set_style(div1, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			set_style(div1, "--color", /*color*/ ctx[0]);
			set_style(div1, "--duration", /*duration*/ ctx[2]);
			set_style(div1, "--duration", /*duration*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size, unit*/ 10) {
				set_style(div1, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			}

			if (dirty & /*color*/ 1) {
				set_style(div1, "--color", /*color*/ ctx[0]);
			}

			if (dirty & /*duration*/ 4) {
				set_style(div1, "--duration", /*duration*/ ctx[2]);
			}

			if (dirty & /*duration*/ 4) {
				set_style(div1, "--duration", /*duration*/ ctx[2]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div1);
		}
	};
}

function instance$i($$self, $$props, $$invalidate) {
	
	let { color = "#FF3E00" } = $$props;
	let { unit = "px" } = $$props;
	let { duration = "1s" } = $$props;
	let { size = "60" } = $$props;

	$$self.$$set = $$props => {
		if ("color" in $$props) $$invalidate(0, color = $$props.color);
		if ("unit" in $$props) $$invalidate(1, unit = $$props.unit);
		if ("duration" in $$props) $$invalidate(2, duration = $$props.duration);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
	};

	return [color, unit, duration, size];
}

class ScaleOut extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-9juun5-style")) add_css$i();
		init(this, options, instance$i, create_fragment$i, safe_not_equal, { color: 0, unit: 1, duration: 2, size: 3 });
	}
}

/* src\SpinLine.svelte generated by Svelte v3.38.3 */

function add_css$h() {
	var style = element("style");
	style.id = "svelte-1wp57lu-style";
	style.textContent = ".wrapper.svelte-1wp57lu{width:var(--size);height:var(--stroke);transform:scale(calc(var(--floatSize) / 75));display:flex;justify-content:center;align-items:center}.line.svelte-1wp57lu{width:var(--size);height:var(--stroke);background:var(--color);border-radius:var(--stroke);transform-origin:center center;animation:svelte-1wp57lu-spineLine var(--duration) ease infinite}@keyframes svelte-1wp57lu-spineLine{0%{transform:rotate(-20deg);height:5px;width:75px}5%{height:5px;width:75px}30%{transform:rotate(380deg);height:5px;width:75px}40%{transform:rotate(360deg);height:5px;width:75px}55%{transform:rotate(0deg);height:5px;width:5px}65%{transform:rotate(0deg);height:5px;width:85px}68%{transform:rotate(0deg);height:5px}75%{transform:rotate(0deg);height:5px;width:1px}78%{height:5px;width:5px}90%{height:5px;width:75px;transform:rotate(0deg)}99%,100%{height:5px;width:75px;transform:rotate(-20deg)}}";
	append(document.head, style);
}

function create_fragment$h(ctx) {
	let div1;
	let div0;

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			attr(div0, "class", "line svelte-1wp57lu");
			attr(div1, "class", "wrapper svelte-1wp57lu");
			set_style(div1, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			set_style(div1, "--color", /*color*/ ctx[0]);
			set_style(div1, "--stroke", /*stroke*/ ctx[4]);
			set_style(div1, "--floatSize", /*size*/ ctx[3]);
			set_style(div1, "--duration", /*duration*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size, unit*/ 10) {
				set_style(div1, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			}

			if (dirty & /*color*/ 1) {
				set_style(div1, "--color", /*color*/ ctx[0]);
			}

			if (dirty & /*stroke*/ 16) {
				set_style(div1, "--stroke", /*stroke*/ ctx[4]);
			}

			if (dirty & /*size*/ 8) {
				set_style(div1, "--floatSize", /*size*/ ctx[3]);
			}

			if (dirty & /*duration*/ 4) {
				set_style(div1, "--duration", /*duration*/ ctx[2]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div1);
		}
	};
}

function instance$h($$self, $$props, $$invalidate) {
	
	let { color = "#FF3E00" } = $$props;
	let { unit = "px" } = $$props;
	let { duration = "4s" } = $$props;
	let { size = "60" } = $$props;
	let { stroke = +size / 12 + unit } = $$props;

	$$self.$$set = $$props => {
		if ("color" in $$props) $$invalidate(0, color = $$props.color);
		if ("unit" in $$props) $$invalidate(1, unit = $$props.unit);
		if ("duration" in $$props) $$invalidate(2, duration = $$props.duration);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("stroke" in $$props) $$invalidate(4, stroke = $$props.stroke);
	};

	return [color, unit, duration, size, stroke];
}

class SpinLine extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1wp57lu-style")) add_css$h();

		init(this, options, instance$h, create_fragment$h, safe_not_equal, {
			color: 0,
			unit: 1,
			duration: 2,
			size: 3,
			stroke: 4
		});
	}
}

/* src\Stretch.svelte generated by Svelte v3.38.3 */

function add_css$g() {
	var style = element("style");
	style.id = "svelte-1uxpkwt-style";
	style.textContent = ".wrapper.svelte-1uxpkwt{height:var(--size);width:var(--size);display:inline-block;text-align:center;font-size:10px}.rect.svelte-1uxpkwt{height:100%;width:10%;display:inline-block;margin-right:4px;background-color:var(--color);animation:svelte-1uxpkwt-stretch var(--duration) ease-in-out infinite}@keyframes svelte-1uxpkwt-stretch{0%,40%,100%{transform:scaleY(0.4)}20%{transform:scaleY(1)}}";
	append(document.head, style);
}

function get_each_context$8(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[6] = list[i];
	return child_ctx;
}

// (42:2) {#each range(5, 1) as version}
function create_each_block$8(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			attr(div, "class", "rect svelte-1uxpkwt");
			set_style(div, "animation-delay", (/*version*/ ctx[6] - 1) * (+/*durationNum*/ ctx[5] / 12) + /*durationUnit*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment$g(ctx) {
	let div;
	let each_value = range(5, 1);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div, "class", "wrapper svelte-1uxpkwt");
			set_style(div, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			set_style(div, "--color", /*color*/ ctx[0]);
			set_style(div, "--duration", /*duration*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*range, durationNum, durationUnit*/ 48) {
				each_value = range(5, 1);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$8(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$8(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*size, unit*/ 10) {
				set_style(div, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			}

			if (dirty & /*color*/ 1) {
				set_style(div, "--color", /*color*/ ctx[0]);
			}

			if (dirty & /*duration*/ 4) {
				set_style(div, "--duration", /*duration*/ ctx[2]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

function instance$g($$self, $$props, $$invalidate) {
	
	let { color = "#FF3E00" } = $$props;
	let { unit = "px" } = $$props;
	let { duration = "1.2s" } = $$props;
	let { size = "60" } = $$props;
	let durationUnit = duration.match(durationUnitRegex)[0];
	let durationNum = duration.replace(durationUnitRegex, "");

	$$self.$$set = $$props => {
		if ("color" in $$props) $$invalidate(0, color = $$props.color);
		if ("unit" in $$props) $$invalidate(1, unit = $$props.unit);
		if ("duration" in $$props) $$invalidate(2, duration = $$props.duration);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
	};

	return [color, unit, duration, size, durationUnit, durationNum];
}

class Stretch extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1uxpkwt-style")) add_css$g();
		init(this, options, instance$g, create_fragment$g, safe_not_equal, { color: 0, unit: 1, duration: 2, size: 3 });
	}
}

/* src\BarLoader.svelte generated by Svelte v3.38.3 */

function add_css$f() {
	var style = element("style");
	style.id = "svelte-vhcw6-style";
	style.textContent = ".wrapper.svelte-vhcw6{height:calc(var(--size) / 15);width:calc(var(--size) * 2);background-color:var(--rgba);position:relative;overflow:hidden;background-clip:padding-box}.lines.svelte-vhcw6{height:calc(var(--size) / 15);background-color:var(--color)}.small-lines.svelte-vhcw6{position:absolute;overflow:hidden;background-clip:padding-box;display:block;border-radius:2px;will-change:left, right;animation-fill-mode:forwards}.small-lines.\\31 .svelte-vhcw6{animation:var(--duration) cubic-bezier(0.65, 0.815, 0.735, 0.395) 0s\r\n      infinite normal none running svelte-vhcw6-long}.small-lines.\\32 .svelte-vhcw6{animation:var(--duration) cubic-bezier(0.165, 0.84, 0.44, 1)\r\n      calc((var(--duration)+0.1) / 2) infinite normal none running svelte-vhcw6-short}@keyframes svelte-vhcw6-long{0%{left:-35%;right:100%}60%{left:100%;right:-90%}100%{left:100%;right:-90%}}@keyframes svelte-vhcw6-short{0%{left:-200%;right:100%}60%{left:107%;right:-8%}100%{left:107%;right:-8%}}";
	append(document.head, style);
}

function get_each_context$7(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	return child_ctx;
}

// (74:2) {#each range(2, 1) as version}
function create_each_block$7(ctx) {
	let div;
	let div_class_value;

	return {
		c() {
			div = element("div");
			attr(div, "class", div_class_value = "lines small-lines " + /*version*/ ctx[5] + " svelte-vhcw6");
			set_style(div, "--color", /*color*/ ctx[0]);
			set_style(div, "--duration", /*duration*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*color*/ 1) {
				set_style(div, "--color", /*color*/ ctx[0]);
			}

			if (dirty & /*duration*/ 4) {
				set_style(div, "--duration", /*duration*/ ctx[2]);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment$f(ctx) {
	let div;
	let each_value = range(2, 1);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div, "class", "wrapper svelte-vhcw6");
			set_style(div, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			set_style(div, "--rgba", /*rgba*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*range, color, duration*/ 5) {
				each_value = range(2, 1);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$7(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$7(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*size, unit*/ 10) {
				set_style(div, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			}

			if (dirty & /*rgba*/ 16) {
				set_style(div, "--rgba", /*rgba*/ ctx[4]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

function instance$f($$self, $$props, $$invalidate) {
	
	let { color = "#FF3E00" } = $$props;
	let { unit = "px" } = $$props;
	let { duration = "2.1s" } = $$props;
	let { size = "60" } = $$props;
	let rgba;

	$$self.$$set = $$props => {
		if ("color" in $$props) $$invalidate(0, color = $$props.color);
		if ("unit" in $$props) $$invalidate(1, unit = $$props.unit);
		if ("duration" in $$props) $$invalidate(2, duration = $$props.duration);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*color*/ 1) {
			$$invalidate(4, rgba = calculateRgba(color, 0.2));
		}
	};

	return [color, unit, duration, size, rgba];
}

class BarLoader extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-vhcw6-style")) add_css$f();
		init(this, options, instance$f, create_fragment$f, safe_not_equal, { color: 0, unit: 1, duration: 2, size: 3 });
	}
}

/* src\Jumper.svelte generated by Svelte v3.38.3 */

function add_css$e() {
	var style = element("style");
	style.id = "svelte-1cy66mt-style";
	style.textContent = ".wrapper.svelte-1cy66mt{width:var(--size);height:var(--size)}.circle.svelte-1cy66mt{border-radius:100%;animation-fill-mode:both;position:absolute;opacity:0;width:var(--size);height:var(--size);background-color:var(--color);animation:svelte-1cy66mt-bounce var(--duration) linear infinite}@keyframes svelte-1cy66mt-bounce{0%{opacity:0;transform:scale(0)}5%{opacity:1}100%{opacity:0;transform:scale(1)}}";
	append(document.head, style);
}

function get_each_context$6(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[6] = list[i];
	return child_ctx;
}

// (44:2) {#each range(3, 1) as version}
function create_each_block$6(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			attr(div, "class", "circle svelte-1cy66mt");
			set_style(div, "animation-delay", /*durationNum*/ ctx[5] / 3 * (/*version*/ ctx[6] - 1) + /*durationUnit*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment$e(ctx) {
	let div;
	let each_value = range(3, 1);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div, "class", "wrapper svelte-1cy66mt");
			set_style(div, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			set_style(div, "--color", /*color*/ ctx[0]);
			set_style(div, "--duration", /*duration*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*durationNum, range, durationUnit*/ 48) {
				each_value = range(3, 1);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$6(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$6(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*size, unit*/ 10) {
				set_style(div, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			}

			if (dirty & /*color*/ 1) {
				set_style(div, "--color", /*color*/ ctx[0]);
			}

			if (dirty & /*duration*/ 4) {
				set_style(div, "--duration", /*duration*/ ctx[2]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

function instance$e($$self, $$props, $$invalidate) {
	
	let { color = "#FF3E00" } = $$props;
	let { unit = "px" } = $$props;
	let { duration = "1s" } = $$props;
	let { size = "60" } = $$props;
	let durationUnit = duration.match(durationUnitRegex)[0];
	let durationNum = duration.replace(durationUnitRegex, "");

	$$self.$$set = $$props => {
		if ("color" in $$props) $$invalidate(0, color = $$props.color);
		if ("unit" in $$props) $$invalidate(1, unit = $$props.unit);
		if ("duration" in $$props) $$invalidate(2, duration = $$props.duration);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
	};

	return [color, unit, duration, size, durationUnit, durationNum];
}

class Jumper extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1cy66mt-style")) add_css$e();
		init(this, options, instance$e, create_fragment$e, safe_not_equal, { color: 0, unit: 1, duration: 2, size: 3 });
	}
}

/* src\RingLoader.svelte generated by Svelte v3.38.3 */

function add_css$d() {
	var style = element("style");
	style.id = "svelte-17ey38u-style";
	style.textContent = ".wrapper.svelte-17ey38u{position:relative;width:var(--size);height:var(--size)}.border.svelte-17ey38u{border-color:var(--color);position:absolute;top:0px;left:0px;width:var(--size);height:var(--size);opacity:0.4;perspective:800px;border-width:6px;border-style:solid;border-image:initial;border-radius:100%}.border.\\31 .svelte-17ey38u{animation:var(--duration) linear 0s infinite normal none running svelte-17ey38u-ringOne}.border.\\32 .svelte-17ey38u{animation:var(--duration) linear 0s infinite normal none running svelte-17ey38u-ringTwo}@keyframes svelte-17ey38u-ringOne{0%{transform:rotateX(0deg) rotateY(0deg) rotateZ(0deg)}100%{transform:rotateX(360deg) rotateY(180deg) rotateZ(360deg)}}@keyframes svelte-17ey38u-ringTwo{0%{transform:rotateX(0deg) rotateY(0deg) rotateZ(0deg)}100%{transform:rotateX(180deg) rotateY(360deg) rotateZ(360deg)}}";
	append(document.head, style);
}

function get_each_context$5(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i];
	return child_ctx;
}

// (57:2) {#each range(2, 1) as version}
function create_each_block$5(ctx) {
	let div;
	let div_class_value;

	return {
		c() {
			div = element("div");
			attr(div, "class", div_class_value = "border " + /*version*/ ctx[4] + " svelte-17ey38u");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment$d(ctx) {
	let div;
	let each_value = range(2, 1);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div, "class", "wrapper svelte-17ey38u");
			set_style(div, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			set_style(div, "--color", /*color*/ ctx[0]);
			set_style(div, "--duration", /*duration*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*range*/ 0) {
				each_value = range(2, 1);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$5(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$5(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*size, unit*/ 10) {
				set_style(div, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			}

			if (dirty & /*color*/ 1) {
				set_style(div, "--color", /*color*/ ctx[0]);
			}

			if (dirty & /*duration*/ 4) {
				set_style(div, "--duration", /*duration*/ ctx[2]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

function instance$d($$self, $$props, $$invalidate) {
	
	let { color = "#FF3E00" } = $$props;
	let { unit = "px" } = $$props;
	let { duration = "2s" } = $$props;
	let { size = "60" } = $$props;

	$$self.$$set = $$props => {
		if ("color" in $$props) $$invalidate(0, color = $$props.color);
		if ("unit" in $$props) $$invalidate(1, unit = $$props.unit);
		if ("duration" in $$props) $$invalidate(2, duration = $$props.duration);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
	};

	return [color, unit, duration, size];
}

class RingLoader extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-17ey38u-style")) add_css$d();
		init(this, options, instance$d, create_fragment$d, safe_not_equal, { color: 0, unit: 1, duration: 2, size: 3 });
	}
}

/* src\SyncLoader.svelte generated by Svelte v3.38.3 */

function add_css$c() {
	var style = element("style");
	style.id = "svelte-14w6xk7-style";
	style.textContent = ".wrapper.svelte-14w6xk7{height:var(--size);width:var(--size);display:flex;align-items:center;justify-content:center}.dot.svelte-14w6xk7{height:var(--dotSize);width:var(--dotSize);background-color:var(--color);margin:2px;display:inline-block;border-radius:100%;animation:svelte-14w6xk7-sync var(--duration) ease-in-out infinite alternate both running}@-webkit-keyframes svelte-14w6xk7-sync{33%{-webkit-transform:translateY(10px);transform:translateY(10px)}66%{-webkit-transform:translateY(-10px);transform:translateY(-10px)}100%{-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes svelte-14w6xk7-sync{33%{-webkit-transform:translateY(10px);transform:translateY(10px)}66%{-webkit-transform:translateY(-10px);transform:translateY(-10px)}100%{-webkit-transform:translateY(0);transform:translateY(0)}}";
	append(document.head, style);
}

function get_each_context$4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[6] = list[i];
	return child_ctx;
}

// (61:2) {#each range(3, 1) as i}
function create_each_block$4(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			attr(div, "class", "dot svelte-14w6xk7");
			set_style(div, "--dotSize", +/*size*/ ctx[3] * 0.25 + /*unit*/ ctx[1]);
			set_style(div, "--color", /*color*/ ctx[0]);
			set_style(div, "animation-delay", /*i*/ ctx[6] * (+/*durationNum*/ ctx[5] / 10) + /*durationUnit*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*size, unit*/ 10) {
				set_style(div, "--dotSize", +/*size*/ ctx[3] * 0.25 + /*unit*/ ctx[1]);
			}

			if (dirty & /*color*/ 1) {
				set_style(div, "--color", /*color*/ ctx[0]);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment$c(ctx) {
	let div;
	let each_value = range(3, 1);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div, "class", "wrapper svelte-14w6xk7");
			set_style(div, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			set_style(div, "--duration", /*duration*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*size, unit, color, range, durationNum, durationUnit*/ 59) {
				each_value = range(3, 1);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$4(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$4(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*size, unit*/ 10) {
				set_style(div, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			}

			if (dirty & /*duration*/ 4) {
				set_style(div, "--duration", /*duration*/ ctx[2]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

function instance$c($$self, $$props, $$invalidate) {
	
	let { color = "#FF3E00" } = $$props;
	let { unit = "px" } = $$props;
	let { duration = "0.6s" } = $$props;
	let { size = "60" } = $$props;
	let durationUnit = duration.match(durationUnitRegex)[0];
	let durationNum = duration.replace(durationUnitRegex, "");

	$$self.$$set = $$props => {
		if ("color" in $$props) $$invalidate(0, color = $$props.color);
		if ("unit" in $$props) $$invalidate(1, unit = $$props.unit);
		if ("duration" in $$props) $$invalidate(2, duration = $$props.duration);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
	};

	return [color, unit, duration, size, durationUnit, durationNum];
}

class SyncLoader extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-14w6xk7-style")) add_css$c();
		init(this, options, instance$c, create_fragment$c, safe_not_equal, { color: 0, unit: 1, duration: 2, size: 3 });
	}
}

/* src\Rainbow.svelte generated by Svelte v3.38.3 */

function add_css$b() {
	var style = element("style");
	style.id = "svelte-1fuumrt-style";
	style.textContent = ".wrapper.svelte-1fuumrt{width:var(--size);height:calc(var(--size) / 2);overflow:hidden}.rainbow.svelte-1fuumrt{width:var(--size);height:var(--size);border-left-color:transparent;border-bottom-color:transparent;border-top-color:var(--color);border-right-color:var(--color);box-sizing:border-box;transform:rotate(-200deg);border-radius:50%;border-style:solid;animation:var(--duration) ease-in-out 0s infinite normal none running\r\n      svelte-1fuumrt-rotate}@keyframes svelte-1fuumrt-rotate{0%{border-width:10px}25%{border-width:3px}50%{transform:rotate(115deg);border-width:10px}75%{border-width:3px}100%{border-width:10px}}";
	append(document.head, style);
}

function create_fragment$b(ctx) {
	let div1;
	let div0;

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			attr(div0, "class", "rainbow svelte-1fuumrt");
			attr(div1, "class", "wrapper svelte-1fuumrt");
			set_style(div1, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			set_style(div1, "--color", /*color*/ ctx[0]);
			set_style(div1, "--duration", /*duration*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size, unit*/ 10) {
				set_style(div1, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			}

			if (dirty & /*color*/ 1) {
				set_style(div1, "--color", /*color*/ ctx[0]);
			}

			if (dirty & /*duration*/ 4) {
				set_style(div1, "--duration", /*duration*/ ctx[2]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div1);
		}
	};
}

function instance$b($$self, $$props, $$invalidate) {
	
	let { color = "#FF3E00" } = $$props;
	let { unit = "px" } = $$props;
	let { duration = "3s" } = $$props;
	let { size = "60" } = $$props;

	$$self.$$set = $$props => {
		if ("color" in $$props) $$invalidate(0, color = $$props.color);
		if ("unit" in $$props) $$invalidate(1, unit = $$props.unit);
		if ("duration" in $$props) $$invalidate(2, duration = $$props.duration);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
	};

	return [color, unit, duration, size];
}

class Rainbow extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1fuumrt-style")) add_css$b();
		init(this, options, instance$b, create_fragment$b, safe_not_equal, { color: 0, unit: 1, duration: 2, size: 3 });
	}
}

/* src\Wave.svelte generated by Svelte v3.38.3 */

function add_css$a() {
	var style = element("style");
	style.id = "svelte-8cmcz4-style";
	style.textContent = ".wrapper.svelte-8cmcz4{position:relative;display:flex;justify-content:center;align-items:center;width:calc(var(--size) * 2.5);height:var(--size);overflow:hidden}.bar.svelte-8cmcz4{position:absolute;top:calc(var(--size) / 10);width:calc(var(--size) / 5);height:calc(var(--size) / 10);margin-top:calc(var(--size) - var(--size) / 10);transform:skewY(0deg);background-color:var(--color);animation:svelte-8cmcz4-motion var(--duration) ease-in-out infinite}@keyframes svelte-8cmcz4-motion{25%{transform:skewY(25deg)}50%{height:100%;margin-top:0}75%{transform:skewY(-25deg)}}";
	append(document.head, style);
}

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[6] = list[i];
	return child_ctx;
}

// (48:2) {#each range(10, 0) as version}
function create_each_block$3(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			attr(div, "class", "bar svelte-8cmcz4");
			set_style(div, "left", /*version*/ ctx[6] * (+/*size*/ ctx[3] / 5 + (+/*size*/ ctx[3] / 15 - +/*size*/ ctx[3] / 100)) + /*unit*/ ctx[1]);
			set_style(div, "animation-delay", /*version*/ ctx[6] * (+/*durationNum*/ ctx[5] / 8.3) + /*durationUnit*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*size, unit*/ 10) {
				set_style(div, "left", /*version*/ ctx[6] * (+/*size*/ ctx[3] / 5 + (+/*size*/ ctx[3] / 15 - +/*size*/ ctx[3] / 100)) + /*unit*/ ctx[1]);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment$a(ctx) {
	let div;
	let each_value = range(10, 0);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div, "class", "wrapper svelte-8cmcz4");
			set_style(div, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			set_style(div, "--color", /*color*/ ctx[0]);
			set_style(div, "--duration", /*duration*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*range, size, unit, durationNum, durationUnit*/ 58) {
				each_value = range(10, 0);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$3(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$3(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*size, unit*/ 10) {
				set_style(div, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			}

			if (dirty & /*color*/ 1) {
				set_style(div, "--color", /*color*/ ctx[0]);
			}

			if (dirty & /*duration*/ 4) {
				set_style(div, "--duration", /*duration*/ ctx[2]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

function instance$a($$self, $$props, $$invalidate) {
	
	let { color = "#FF3E00" } = $$props;
	let { unit = "px" } = $$props;
	let { duration = "1.25s" } = $$props;
	let { size = "60" } = $$props;
	let durationUnit = duration.match(durationUnitRegex)[0];
	let durationNum = duration.replace(durationUnitRegex, "");

	$$self.$$set = $$props => {
		if ("color" in $$props) $$invalidate(0, color = $$props.color);
		if ("unit" in $$props) $$invalidate(1, unit = $$props.unit);
		if ("duration" in $$props) $$invalidate(2, duration = $$props.duration);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
	};

	return [color, unit, duration, size, durationUnit, durationNum];
}

class Wave extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-8cmcz4-style")) add_css$a();
		init(this, options, instance$a, create_fragment$a, safe_not_equal, { color: 0, unit: 1, duration: 2, size: 3 });
	}
}

/* src\Firework.svelte generated by Svelte v3.38.3 */

function add_css$9() {
	var style = element("style");
	style.id = "svelte-1x2s7pr-style";
	style.textContent = ".wrapper.svelte-1x2s7pr{width:calc(var(--size) * 1.3);height:calc(var(--size) * 1.3);display:flex;justify-content:center;align-items:center}.firework.svelte-1x2s7pr{border:calc(var(--size) / 10) dotted var(--color);width:var(--size);height:var(--size);border-radius:50%;animation:svelte-1x2s7pr-fire var(--duration) cubic-bezier(0.165, 0.84, 0.44, 1) infinite}@keyframes svelte-1x2s7pr-fire{0%{opacity:1;transform:scale(0.1)}25%{opacity:0.85}100%{transform:scale(1);opacity:0}}";
	append(document.head, style);
}

function create_fragment$9(ctx) {
	let div1;
	let div0;

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			attr(div0, "class", "firework svelte-1x2s7pr");
			attr(div1, "class", "wrapper svelte-1x2s7pr");
			set_style(div1, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			set_style(div1, "--color", /*color*/ ctx[0]);
			set_style(div1, "--duration", /*duration*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size, unit*/ 10) {
				set_style(div1, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			}

			if (dirty & /*color*/ 1) {
				set_style(div1, "--color", /*color*/ ctx[0]);
			}

			if (dirty & /*duration*/ 4) {
				set_style(div1, "--duration", /*duration*/ ctx[2]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div1);
		}
	};
}

function instance$9($$self, $$props, $$invalidate) {
	
	let { color = "#FF3E00" } = $$props;
	let { unit = "px" } = $$props;
	let { duration = "1.25s" } = $$props;
	let { size = "60" } = $$props;

	$$self.$$set = $$props => {
		if ("color" in $$props) $$invalidate(0, color = $$props.color);
		if ("unit" in $$props) $$invalidate(1, unit = $$props.unit);
		if ("duration" in $$props) $$invalidate(2, duration = $$props.duration);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
	};

	return [color, unit, duration, size];
}

class Firework extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1x2s7pr-style")) add_css$9();
		init(this, options, instance$9, create_fragment$9, safe_not_equal, { color: 0, unit: 1, duration: 2, size: 3 });
	}
}

/* src\Pulse.svelte generated by Svelte v3.38.3 */

function add_css$8() {
	var style = element("style");
	style.id = "svelte-446r86-style";
	style.textContent = ".wrapper.svelte-446r86{position:relative;display:flex;justify-content:center;align-items:center;width:var(--size);height:calc(var(--size) / 2.5)}.cube.svelte-446r86{position:absolute;top:0px;width:calc(var(--size) / 5);height:calc(var(--size) / 2.5);background-color:var(--color);animation:svelte-446r86-motion var(--duration) cubic-bezier(0.895, 0.03, 0.685, 0.22)\r\n      infinite}@keyframes svelte-446r86-motion{0%{opacity:1}50%{opacity:0}100%{opacity:1}}";
	append(document.head, style);
}

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[6] = list[i];
	return child_ctx;
}

// (45:2) {#each range(3, 0) as version}
function create_each_block$2(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			attr(div, "class", "cube svelte-446r86");
			set_style(div, "animation-delay", /*version*/ ctx[6] * (+/*durationNum*/ ctx[5] / 10) + /*durationUnit*/ ctx[4]);
			set_style(div, "left", /*version*/ ctx[6] * (+/*size*/ ctx[3] / 3 + +/*size*/ ctx[3] / 15) + /*unit*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*size, unit*/ 10) {
				set_style(div, "left", /*version*/ ctx[6] * (+/*size*/ ctx[3] / 3 + +/*size*/ ctx[3] / 15) + /*unit*/ ctx[1]);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment$8(ctx) {
	let div;
	let each_value = range(3, 0);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div, "class", "wrapper svelte-446r86");
			set_style(div, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			set_style(div, "--color", /*color*/ ctx[0]);
			set_style(div, "--duration", /*duration*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*range, durationNum, durationUnit, size, unit*/ 58) {
				each_value = range(3, 0);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*size, unit*/ 10) {
				set_style(div, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			}

			if (dirty & /*color*/ 1) {
				set_style(div, "--color", /*color*/ ctx[0]);
			}

			if (dirty & /*duration*/ 4) {
				set_style(div, "--duration", /*duration*/ ctx[2]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

function instance$8($$self, $$props, $$invalidate) {
	
	let { color = "#FF3E00" } = $$props;
	let { unit = "px" } = $$props;
	let { duration = "1.5s" } = $$props;
	let { size = "60" } = $$props;
	let durationUnit = duration.match(durationUnitRegex)[0];
	let durationNum = duration.replace(durationUnitRegex, "");

	$$self.$$set = $$props => {
		if ("color" in $$props) $$invalidate(0, color = $$props.color);
		if ("unit" in $$props) $$invalidate(1, unit = $$props.unit);
		if ("duration" in $$props) $$invalidate(2, duration = $$props.duration);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
	};

	return [color, unit, duration, size, durationUnit, durationNum];
}

class Pulse extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-446r86-style")) add_css$8();
		init(this, options, instance$8, create_fragment$8, safe_not_equal, { color: 0, unit: 1, duration: 2, size: 3 });
	}
}

/* src\Jellyfish.svelte generated by Svelte v3.38.3 */

function add_css$7() {
	var style = element("style");
	style.id = "svelte-1v1mfqa-style";
	style.textContent = ".wrapper.svelte-1v1mfqa{position:relative;display:flex;justify-content:center;align-items:center;width:var(--size);height:var(--size)}.ring.svelte-1v1mfqa{position:absolute;border:2px solid var(--color);border-radius:50%;background-color:transparent;animation:svelte-1v1mfqa-motion var(--duration) ease infinite}@keyframes svelte-1v1mfqa-motion{0%{transform:translateY(var(--motionOne))}50%{transform:translateY(var(--motionTwo))}100%{transform:translateY(var(--motionThree))}}";
	append(document.head, style);
}

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[6] = list[i];
	return child_ctx;
}

// (43:2) {#each range(6, 0) as version}
function create_each_block$1(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			attr(div, "class", "ring svelte-1v1mfqa");
			set_style(div, "animation-delay", /*version*/ ctx[6] * (/*durationNum*/ ctx[5] / 25) + /*durationUnit*/ ctx[4]);
			set_style(div, "width", /*version*/ ctx[6] * (+/*size*/ ctx[3] / 6) + /*unit*/ ctx[1]);
			set_style(div, "height", /*version*/ ctx[6] * (+/*size*/ ctx[3] / 6) / 2 + /*unit*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*size, unit*/ 10) {
				set_style(div, "width", /*version*/ ctx[6] * (+/*size*/ ctx[3] / 6) + /*unit*/ ctx[1]);
			}

			if (dirty & /*size, unit*/ 10) {
				set_style(div, "height", /*version*/ ctx[6] * (+/*size*/ ctx[3] / 6) / 2 + /*unit*/ ctx[1]);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment$7(ctx) {
	let div;
	let each_value = range(6, 0);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div, "class", "wrapper svelte-1v1mfqa");
			set_style(div, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			set_style(div, "--color", /*color*/ ctx[0]);
			set_style(div, "--motionOne", -/*size*/ ctx[3] / 5 + /*unit*/ ctx[1]);
			set_style(div, "--motionTwo", +/*size*/ ctx[3] / 4 + /*unit*/ ctx[1]);
			set_style(div, "--motionThree", -/*size*/ ctx[3] / 5 + /*unit*/ ctx[1]);
			set_style(div, "--duration", /*duration*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*range, durationNum, durationUnit, size, unit*/ 58) {
				each_value = range(6, 0);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*size, unit*/ 10) {
				set_style(div, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			}

			if (dirty & /*color*/ 1) {
				set_style(div, "--color", /*color*/ ctx[0]);
			}

			if (dirty & /*size, unit*/ 10) {
				set_style(div, "--motionOne", -/*size*/ ctx[3] / 5 + /*unit*/ ctx[1]);
			}

			if (dirty & /*size, unit*/ 10) {
				set_style(div, "--motionTwo", +/*size*/ ctx[3] / 4 + /*unit*/ ctx[1]);
			}

			if (dirty & /*size, unit*/ 10) {
				set_style(div, "--motionThree", -/*size*/ ctx[3] / 5 + /*unit*/ ctx[1]);
			}

			if (dirty & /*duration*/ 4) {
				set_style(div, "--duration", /*duration*/ ctx[2]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

function instance$7($$self, $$props, $$invalidate) {
	
	let { color = "#FF3E00" } = $$props;
	let { unit = "px" } = $$props;
	let { duration = "2.5s" } = $$props;
	let { size = "60" } = $$props;
	let durationUnit = duration.match(durationUnitRegex)[0];
	let durationNum = duration.replace(durationUnitRegex, "");

	$$self.$$set = $$props => {
		if ("color" in $$props) $$invalidate(0, color = $$props.color);
		if ("unit" in $$props) $$invalidate(1, unit = $$props.unit);
		if ("duration" in $$props) $$invalidate(2, duration = $$props.duration);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
	};

	return [color, unit, duration, size, durationUnit, durationNum];
}

class Jellyfish extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1v1mfqa-style")) add_css$7();
		init(this, options, instance$7, create_fragment$7, safe_not_equal, { color: 0, unit: 1, duration: 2, size: 3 });
	}
}

/* src\Chasing.svelte generated by Svelte v3.38.3 */

function add_css$6() {
	var style = element("style");
	style.id = "svelte-1unnvn6-style";
	style.textContent = ".wrapper.svelte-1unnvn6{height:var(--size);width:var(--size);display:flex;justify-content:center;align-items:center}.spinner.svelte-1unnvn6{height:var(--size);width:var(--size);animation:svelte-1unnvn6-rotate var(--duration) infinite linear}.dot.svelte-1unnvn6{width:60%;height:60%;display:inline-block;position:absolute;top:0;background-color:var(--color);border-radius:100%;animation:svelte-1unnvn6-bounce var(--duration) infinite ease-in-out}@keyframes svelte-1unnvn6-rotate{100%{transform:rotate(360deg)}}@keyframes svelte-1unnvn6-bounce{0%,100%{transform:scale(0)}50%{transform:scale(1)}}";
	append(document.head, style);
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[6] = list[i];
	return child_ctx;
}

// (55:4) {#each range(2, 0) as version}
function create_each_block(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			attr(div, "class", "dot svelte-1unnvn6");

			set_style(div, "animation-delay", /*version*/ ctx[6] === 1
			? `${/*durationNum*/ ctx[5] / 2}${/*durationUnit*/ ctx[4]}`
			: "0s");

			set_style(div, "bottom", /*version*/ ctx[6] === 1 ? "0" : "");
			set_style(div, "top", /*version*/ ctx[6] === 1 ? "auto" : "");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment$6(ctx) {
	let div1;
	let div0;
	let each_value = range(2, 0);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			div1 = element("div");
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div0, "class", "spinner svelte-1unnvn6");
			attr(div1, "class", "wrapper svelte-1unnvn6");
			set_style(div1, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			set_style(div1, "--color", /*color*/ ctx[0]);
			set_style(div1, "--duration", /*duration*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div0, null);
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*range, durationNum, durationUnit*/ 48) {
				each_value = range(2, 0);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*size, unit*/ 10) {
				set_style(div1, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			}

			if (dirty & /*color*/ 1) {
				set_style(div1, "--color", /*color*/ ctx[0]);
			}

			if (dirty & /*duration*/ 4) {
				set_style(div1, "--duration", /*duration*/ ctx[2]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div1);
			destroy_each(each_blocks, detaching);
		}
	};
}

function instance$6($$self, $$props, $$invalidate) {
	
	let { color = "#FF3E00" } = $$props;
	let { unit = "px" } = $$props;
	let { duration = "2s" } = $$props;
	let { size = "60" } = $$props;
	let durationUnit = duration.match(durationUnitRegex)[0];
	let durationNum = duration.replace(durationUnitRegex, "");

	$$self.$$set = $$props => {
		if ("color" in $$props) $$invalidate(0, color = $$props.color);
		if ("unit" in $$props) $$invalidate(1, unit = $$props.unit);
		if ("duration" in $$props) $$invalidate(2, duration = $$props.duration);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
	};

	return [color, unit, duration, size, durationUnit, durationNum];
}

class Chasing extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1unnvn6-style")) add_css$6();
		init(this, options, instance$6, create_fragment$6, safe_not_equal, { color: 0, unit: 1, duration: 2, size: 3 });
	}
}

/* src\Shadow.svelte generated by Svelte v3.38.3 */

function add_css$5() {
	var style = element("style");
	style.id = "svelte-tycttu-style";
	style.textContent = ".wrapper.svelte-tycttu{position:relative;display:flex;justify-content:center;align-items:center;width:var(--size);height:var(--size)}.shadow.svelte-tycttu{color:var(--color);font-size:var(--size);overflow:hidden;width:var(--size);height:var(--size);border-radius:50%;margin:28px auto;position:relative;transform:translateZ(0);animation:svelte-tycttu-load var(--duration) infinite ease,\r\n      svelte-tycttu-round var(--duration) infinite ease}@keyframes svelte-tycttu-load{0%{box-shadow:0 -0.83em 0 -0.4em, 0 -0.83em 0 -0.42em, 0 -0.83em 0 -0.44em,\r\n        0 -0.83em 0 -0.46em, 0 -0.83em 0 -0.477em}5%,95%{box-shadow:0 -0.83em 0 -0.4em, 0 -0.83em 0 -0.42em, 0 -0.83em 0 -0.44em,\r\n        0 -0.83em 0 -0.46em, 0 -0.83em 0 -0.477em}10%,59%{box-shadow:0 -0.83em 0 -0.4em, -0.087em -0.825em 0 -0.42em,\r\n        -0.173em -0.812em 0 -0.44em, -0.256em -0.789em 0 -0.46em,\r\n        -0.297em -0.775em 0 -0.477em}20%{box-shadow:0 -0.83em 0 -0.4em, -0.338em -0.758em 0 -0.42em,\r\n        -0.555em -0.617em 0 -0.44em, -0.671em -0.488em 0 -0.46em,\r\n        -0.749em -0.34em 0 -0.477em}38%{box-shadow:0 -0.83em 0 -0.4em, -0.377em -0.74em 0 -0.42em,\r\n        -0.645em -0.522em 0 -0.44em, -0.775em -0.297em 0 -0.46em,\r\n        -0.82em -0.09em 0 -0.477em}100%{box-shadow:0 -0.83em 0 -0.4em, 0 -0.83em 0 -0.42em, 0 -0.83em 0 -0.44em,\r\n        0 -0.83em 0 -0.46em, 0 -0.83em 0 -0.477em}}@keyframes svelte-tycttu-round{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}";
	append(document.head, style);
}

function create_fragment$5(ctx) {
	let div1;
	let div0;

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			attr(div0, "class", "shadow svelte-tycttu");
			attr(div1, "class", "wrapper svelte-tycttu");
			set_style(div1, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			set_style(div1, "--color", /*color*/ ctx[0]);
			set_style(div1, "--duration", /*duration*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size, unit*/ 10) {
				set_style(div1, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			}

			if (dirty & /*color*/ 1) {
				set_style(div1, "--color", /*color*/ ctx[0]);
			}

			if (dirty & /*duration*/ 4) {
				set_style(div1, "--duration", /*duration*/ ctx[2]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div1);
		}
	};
}

function instance$5($$self, $$props, $$invalidate) {
	
	let { color = "#FF3E00" } = $$props;
	let { unit = "px" } = $$props;
	let { duration = "1.7s" } = $$props;
	let { size = "60" } = $$props;

	$$self.$$set = $$props => {
		if ("color" in $$props) $$invalidate(0, color = $$props.color);
		if ("unit" in $$props) $$invalidate(1, unit = $$props.unit);
		if ("duration" in $$props) $$invalidate(2, duration = $$props.duration);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
	};

	return [color, unit, duration, size];
}

class Shadow extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-tycttu-style")) add_css$5();
		init(this, options, instance$5, create_fragment$5, safe_not_equal, { color: 0, unit: 1, duration: 2, size: 3 });
	}
}

/* src\Square.svelte generated by Svelte v3.38.3 */

function add_css$4() {
	var style = element("style");
	style.id = "svelte-btmyrn-style";
	style.textContent = ".square.svelte-btmyrn{height:var(--size);width:var(--size);background-color:var(--color);animation:svelte-btmyrn-squareDelay var(--duration) 0s infinite\r\n      cubic-bezier(0.09, 0.57, 0.49, 0.9);animation-fill-mode:both;perspective:100px;display:inline-block}@keyframes svelte-btmyrn-squareDelay{25%{-webkit-transform:rotateX(180deg) rotateY(0);transform:rotateX(180deg) rotateY(0)}50%{-webkit-transform:rotateX(180deg) rotateY(180deg);transform:rotateX(180deg) rotateY(180deg)}75%{-webkit-transform:rotateX(0) rotateY(180deg);transform:rotateX(0) rotateY(180deg)}100%{-webkit-transform:rotateX(0) rotateY(0);transform:rotateX(0) rotateY(0)}}";
	append(document.head, style);
}

function create_fragment$4(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			attr(div, "class", "square svelte-btmyrn");
			set_style(div, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			set_style(div, "--color", /*color*/ ctx[0]);
			set_style(div, "--duration", /*duration*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size, unit*/ 10) {
				set_style(div, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			}

			if (dirty & /*color*/ 1) {
				set_style(div, "--color", /*color*/ ctx[0]);
			}

			if (dirty & /*duration*/ 4) {
				set_style(div, "--duration", /*duration*/ ctx[2]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	
	let { color = "#FF3E00" } = $$props;
	let { unit = "px" } = $$props;
	let { duration = "3s" } = $$props;
	let { size = "60" } = $$props;

	$$self.$$set = $$props => {
		if ("color" in $$props) $$invalidate(0, color = $$props.color);
		if ("unit" in $$props) $$invalidate(1, unit = $$props.unit);
		if ("duration" in $$props) $$invalidate(2, duration = $$props.duration);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
	};

	return [color, unit, duration, size];
}

class Square extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-btmyrn-style")) add_css$4();
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { color: 0, unit: 1, duration: 2, size: 3 });
	}
}

/* src\Moon.svelte generated by Svelte v3.38.3 */

function add_css$3() {
	var style = element("style");
	style.id = "svelte-nlgli4-style";
	style.textContent = ".wrapper.svelte-nlgli4{height:var(--size);width:var(--size);border-radius:100%;animation:svelte-nlgli4-moonStretchDelay var(--duration) 0s infinite linear;animation-fill-mode:forwards;position:relative}.circle-one.svelte-nlgli4{top:var(--moonSize);background-color:var(--color);width:calc(var(--size) / 7);height:calc(var(--size) / 7);border-radius:100%;animation:svelte-nlgli4-moonStretchDelay var(--duration) 0s infinite linear;animation-fill-mode:forwards;opacity:0.8;position:absolute}.circle-two.svelte-nlgli4{opacity:0.1;border:calc(var(--size) / 7) solid var(--color);height:var(--size);width:var(--size);border-radius:100%;box-sizing:border-box}@keyframes svelte-nlgli4-moonStretchDelay{100%{transform:rotate(360deg)}}";
	append(document.head, style);
}

function create_fragment$3(ctx) {
	let div2;
	let div0;
	let t;
	let div1;

	return {
		c() {
			div2 = element("div");
			div0 = element("div");
			t = space();
			div1 = element("div");
			attr(div0, "class", "circle-one svelte-nlgli4");
			attr(div1, "class", "circle-two svelte-nlgli4");
			attr(div2, "class", "wrapper svelte-nlgli4");
			set_style(div2, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			set_style(div2, "--color", /*color*/ ctx[0]);
			set_style(div2, "--moonSize", /*top*/ ctx[4] + /*unit*/ ctx[1]);
			set_style(div2, "--duration", /*duration*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div0);
			append(div2, t);
			append(div2, div1);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size, unit*/ 10) {
				set_style(div2, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			}

			if (dirty & /*color*/ 1) {
				set_style(div2, "--color", /*color*/ ctx[0]);
			}

			if (dirty & /*unit*/ 2) {
				set_style(div2, "--moonSize", /*top*/ ctx[4] + /*unit*/ ctx[1]);
			}

			if (dirty & /*duration*/ 4) {
				set_style(div2, "--duration", /*duration*/ ctx[2]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div2);
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	
	let { color = "#FF3E00" } = $$props;
	let { unit = "px" } = $$props;
	let { duration = "0.6s" } = $$props;
	let { size = "60" } = $$props;
	let moonSize = +size / 7;
	let top = +size / 2 - moonSize / 2;

	$$self.$$set = $$props => {
		if ("color" in $$props) $$invalidate(0, color = $$props.color);
		if ("unit" in $$props) $$invalidate(1, unit = $$props.unit);
		if ("duration" in $$props) $$invalidate(2, duration = $$props.duration);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
	};

	return [color, unit, duration, size, top];
}

class Moon extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-nlgli4-style")) add_css$3();
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { color: 0, unit: 1, duration: 2, size: 3 });
	}
}

/* src\Plane.svelte generated by Svelte v3.38.3 */

function add_css$2() {
	var style = element("style");
	style.id = "svelte-1sqavxm-style";
	style.textContent = ".wrapper.svelte-1sqavxm.svelte-1sqavxm{height:var(--size);width:var(--size);position:relative;display:flex;justify-content:center;align-items:center}.wrapper.svelte-1sqavxm .svelte-1sqavxm{line-height:0;box-sizing:border-box}.spinner-inner.svelte-1sqavxm.svelte-1sqavxm{height:var(--size);width:var(--size);transform:scale(calc(var(--size) / 70))}.mask.svelte-1sqavxm.svelte-1sqavxm{position:absolute;border-radius:2px;overflow:hidden;perspective:1000;backface-visibility:hidden}.plane.svelte-1sqavxm.svelte-1sqavxm{background:var(--color);width:400%;height:100%;position:absolute;z-index:100;perspective:1000;backface-visibility:hidden}#top.svelte-1sqavxm .plane.svelte-1sqavxm{z-index:2000;animation:svelte-1sqavxm-trans1 var(--duration) ease-in infinite 0s backwards}#middle.svelte-1sqavxm .plane.svelte-1sqavxm{transform:translate3d(0px, 0, 0);background:var(--rgba);animation:svelte-1sqavxm-trans2 var(--duration) linear infinite calc(var(--duration) / 4)\r\n      backwards}#bottom.svelte-1sqavxm .plane.svelte-1sqavxm{z-index:2000;animation:svelte-1sqavxm-trans3 var(--duration) ease-out infinite\r\n      calc(var(--duration) / 2) backwards}#top.svelte-1sqavxm.svelte-1sqavxm{width:53px;height:20px;left:20px;top:5px;transform:skew(-15deg, 0);z-index:100}#middle.svelte-1sqavxm.svelte-1sqavxm{width:33px;height:20px;left:20px;top:21px;transform:skew(-15deg, 40deg)}#bottom.svelte-1sqavxm.svelte-1sqavxm{width:53px;height:20px;top:35px;transform:skew(-15deg, 0)}@keyframes svelte-1sqavxm-trans1{from{transform:translate3d(53px, 0, 0)}to{transform:translate3d(-250px, 0, 0)}}@keyframes svelte-1sqavxm-trans2{from{transform:translate3d(-160px, 0, 0)}to{transform:translate3d(53px, 0, 0)}}@keyframes svelte-1sqavxm-trans3{from{transform:translate3d(53px, 0, 0)}to{transform:translate3d(-220px, 0, 0)}}";
	append(document.head, style);
}

function create_fragment$2(ctx) {
	let div7;
	let div6;

	return {
		c() {
			div7 = element("div");
			div6 = element("div");

			div6.innerHTML = `<div id="top" class="mask svelte-1sqavxm"><div class="plane svelte-1sqavxm"></div></div> 
    <div id="middle" class="mask svelte-1sqavxm"><div class="plane svelte-1sqavxm"></div></div> 
    <div id="bottom" class="mask svelte-1sqavxm"><div class="plane svelte-1sqavxm"></div></div>`;

			attr(div6, "class", "spinner-inner svelte-1sqavxm");
			attr(div7, "class", "wrapper svelte-1sqavxm");
			set_style(div7, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			set_style(div7, "--color", /*color*/ ctx[0]);
			set_style(div7, "--rgba", /*rgba*/ ctx[4]);
			set_style(div7, "--duration", /*duration*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div7, anchor);
			append(div7, div6);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size, unit*/ 10) {
				set_style(div7, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			}

			if (dirty & /*color*/ 1) {
				set_style(div7, "--color", /*color*/ ctx[0]);
			}

			if (dirty & /*rgba*/ 16) {
				set_style(div7, "--rgba", /*rgba*/ ctx[4]);
			}

			if (dirty & /*duration*/ 4) {
				set_style(div7, "--duration", /*duration*/ ctx[2]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div7);
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	
	let { color = "#FF3E00" } = $$props;
	let { unit = "px" } = $$props;
	let { duration = "1.3s" } = $$props;
	let { size = "60" } = $$props;
	let rgba;

	$$self.$$set = $$props => {
		if ("color" in $$props) $$invalidate(0, color = $$props.color);
		if ("unit" in $$props) $$invalidate(1, unit = $$props.unit);
		if ("duration" in $$props) $$invalidate(2, duration = $$props.duration);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*color*/ 1) {
			$$invalidate(4, rgba = calculateRgba(color, 0.6));
		}
	};

	return [color, unit, duration, size, rgba];
}

class Plane extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1sqavxm-style")) add_css$2();
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { color: 0, unit: 1, duration: 2, size: 3 });
	}
}

/* src\Diamonds.svelte generated by Svelte v3.38.3 */

function add_css$1() {
	var style = element("style");
	style.id = "svelte-evhfle-style";
	style.textContent = "span.svelte-evhfle{width:var(--size);height:calc(var(--size) / 4);position:relative;display:block}div.svelte-evhfle{width:calc(var(--size) / 4);height:calc(var(--size) / 4);position:absolute;left:0;top:0;border-radius:2px;background:var(--color);transform:translateX(-50%) rotate(45deg) scale(0);animation:svelte-evhfle-diamonds var(--duration) linear infinite}div.svelte-evhfle:nth-child(1){animation-delay:calc(var(--duration) * 2 / 3 * -1)}div.svelte-evhfle:nth-child(2){animation-delay:calc(var(--duration) * 2 / 3 * -2)}div.svelte-evhfle:nth-child(3){animation-delay:calc(var(--duration) * 2 / 3 * -3)}@keyframes svelte-evhfle-diamonds{50%{left:50%;transform:translateX(-50%) rotate(45deg) scale(1)}100%{left:100%;transform:translateX(-50%) rotate(45deg) scale(0)}}";
	append(document.head, style);
}

function create_fragment$1(ctx) {
	let span;
	let div0;
	let t0;
	let div1;
	let t1;
	let div2;

	return {
		c() {
			span = element("span");
			div0 = element("div");
			t0 = space();
			div1 = element("div");
			t1 = space();
			div2 = element("div");
			attr(div0, "class", "svelte-evhfle");
			attr(div1, "class", "svelte-evhfle");
			attr(div2, "class", "svelte-evhfle");
			set_style(span, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			set_style(span, "--color", /*color*/ ctx[0]);
			set_style(span, "--duration", /*duration*/ ctx[2]);
			attr(span, "class", "svelte-evhfle");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, div0);
			append(span, t0);
			append(span, div1);
			append(span, t1);
			append(span, div2);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size, unit*/ 10) {
				set_style(span, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			}

			if (dirty & /*color*/ 1) {
				set_style(span, "--color", /*color*/ ctx[0]);
			}

			if (dirty & /*duration*/ 4) {
				set_style(span, "--duration", /*duration*/ ctx[2]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	
	let { color = "#FF3E00" } = $$props;
	let { unit = "px" } = $$props;
	let { duration = "1.5s" } = $$props;
	let { size = "60" } = $$props;

	$$self.$$set = $$props => {
		if ("color" in $$props) $$invalidate(0, color = $$props.color);
		if ("unit" in $$props) $$invalidate(1, unit = $$props.unit);
		if ("duration" in $$props) $$invalidate(2, duration = $$props.duration);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
	};

	return [color, unit, duration, size];
}

class Diamonds extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-evhfle-style")) add_css$1();
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { color: 0, unit: 1, duration: 2, size: 3 });
	}
}

/* src\Clock.svelte generated by Svelte v3.38.3 */

function add_css() {
	var style = element("style");
	style.id = "svelte-1cgj772-style";
	style.textContent = "div.svelte-1cgj772{position:relative;width:var(--size);height:var(--size);background-color:transparent;box-shadow:inset 0px 0px 0px 2px var(--color);border-radius:50%}div.svelte-1cgj772::before,div.svelte-1cgj772:after{position:absolute;content:\"\";background-color:var(--color)}div.svelte-1cgj772:after{width:calc(var(--size) / 2.4);height:2px;top:calc(var(--size) / 2);left:calc(var(--size) / 2);transform-origin:1px 1px;animation:svelte-1cgj772-rotate calc(var(--duration) / 4) linear infinite}div.svelte-1cgj772:before{width:calc(var(--size) / 3);height:2px;top:calc((var(--size) / 2));left:calc((var(--size) / 2));transform-origin:1px 1px;animation:svelte-1cgj772-rotate var(--duration) linear infinite}@keyframes svelte-1cgj772-rotate{100%{transform:rotate(360deg)}}";
	append(document.head, style);
}

function create_fragment(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			set_style(div, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			set_style(div, "--color", /*color*/ ctx[0]);
			set_style(div, "--duration", /*duration*/ ctx[2]);
			attr(div, "class", "svelte-1cgj772");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size, unit*/ 10) {
				set_style(div, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
			}

			if (dirty & /*color*/ 1) {
				set_style(div, "--color", /*color*/ ctx[0]);
			}

			if (dirty & /*duration*/ 4) {
				set_style(div, "--duration", /*duration*/ ctx[2]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	
	let { color = "#FF3E00" } = $$props;
	let { unit = "px" } = $$props;
	let { duration = "8s" } = $$props;
	let { size = "60" } = $$props;

	$$self.$$set = $$props => {
		if ("color" in $$props) $$invalidate(0, color = $$props.color);
		if ("unit" in $$props) $$invalidate(1, unit = $$props.unit);
		if ("duration" in $$props) $$invalidate(2, duration = $$props.duration);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
	};

	return [color, unit, duration, size];
}

class Clock extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1cgj772-style")) add_css();
		init(this, options, instance, create_fragment, safe_not_equal, { color: 0, unit: 1, duration: 2, size: 3 });
	}
}

export { BarLoader, Chasing, Circle, Circle2, Circle3, Clock, Diamonds, DoubleBounce, Firework, GoogleSpin, Jellyfish, Jumper, Moon, Plane, Pulse, Rainbow, RingLoader, ScaleOut, Shadow, SpinLine, Square, Stretch, SyncLoader, Wave };
//# sourceMappingURL=index.mjs.map
