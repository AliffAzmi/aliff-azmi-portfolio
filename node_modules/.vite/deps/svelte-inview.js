import "./chunk-RSJERJUL.js";

// node_modules/svelte-inview/dist/index.mjs
var defaultOptions = {
  root: null,
  rootMargin: "0px",
  threshold: 0,
  unobserveOnEnter: false
};
var createEvent = (name, detail) => new CustomEvent(name, { detail });
function inview(node, options = {}) {
  const { root, rootMargin, threshold, unobserveOnEnter } = Object.assign(Object.assign({}, defaultOptions), options);
  let prevPos = {
    x: void 0,
    y: void 0
  };
  let scrollDirection = {
    vertical: void 0,
    horizontal: void 0
  };
  if (typeof IntersectionObserver !== "undefined" && node) {
    const observer = new IntersectionObserver((entries, _observer) => {
      entries.forEach((singleEntry) => {
        if (prevPos.y > singleEntry.boundingClientRect.y) {
          scrollDirection.vertical = "up";
        } else {
          scrollDirection.vertical = "down";
        }
        if (prevPos.x > singleEntry.boundingClientRect.x) {
          scrollDirection.horizontal = "left";
        } else {
          scrollDirection.horizontal = "right";
        }
        prevPos = {
          y: singleEntry.boundingClientRect.y,
          x: singleEntry.boundingClientRect.x
        };
        const detail = {
          inView: singleEntry.isIntersecting,
          entry: singleEntry,
          scrollDirection,
          node,
          observer: _observer
        };
        node.dispatchEvent(createEvent("change", detail));
        if (singleEntry.isIntersecting) {
          node.dispatchEvent(createEvent("enter", detail));
          unobserveOnEnter && _observer.unobserve(node);
        } else {
          node.dispatchEvent(createEvent("leave", detail));
        }
      });
    }, {
      root,
      rootMargin,
      threshold
    });
    setTimeout(() => {
      node.dispatchEvent(createEvent("init", { observer, node }));
    }, 0);
    observer.observe(node);
    return {
      destroy() {
        observer.unobserve(node);
      }
    };
  }
}
export {
  inview
};
//# sourceMappingURL=svelte-inview.js.map
